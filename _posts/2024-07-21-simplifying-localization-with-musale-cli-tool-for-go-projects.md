---
layout: post
title: Dil Desteğini `musale` ile Basitleştirmek: Go Projeleri için Bir CLI Aracı ve Dil Yönetim Yaklaşımı
date: 2024-07-21 15:30 +0300
categories: [Go, Golang, Internationalization, Localization, Language]
tags: [all, important, go, golang, language]
description: Dil Desteği, özellikle küresel bir kitleye hizmet eden uygulamalar oluştururken modern yazılım geliştirmenin...
---
# Dil Desteğini `musale` ile Basitleştirmek: Go Projeleri için Bir CLI Aracı ve Dil Yönetim Yaklaşımı

Dil Desteği, özellikle küresel bir kitleye hizmet eden uygulamalar oluştururken modern yazılım geliştirmenin çok önemli bir yönüdür. Doğru Dil Desteği, uygulamanızın birden fazla dilde erişilebilir ve kullanıcı dostu olmasını sağlar. Ancak Dil Desteği anahtarlarını yönetmek ve bunları kodunuza entegre etmek zahmetli olabilir. Go sabitleri olarak Dil Desteği anahtarları oluşturma sürecini kolaylaştırmak için tasarlanmış bir CLI aracı olan `musale` ile geliştirme iş akışınızı daha verimli ve düzenli hale getirin.

## `musale` nedir?

`musale`, Dil Desteği JSON dosyalarını Go sabitlerine dönüştürme görevini basitleştiren bir komut satırı arayüzü (CLI) aracıdır. Bu araç, bir JSON dosyasından Dil Desteği anahtarları için sabitler oluşturma işlemini otomatikleştirir ve daha sonra çevirileri etkili bir şekilde yönetmek için Go projelerinizde kullanılabilir.

## Temel Özellikler

- **JSON'dan Go Sabitlerine:** Bir JSON dosyasındaki Dil Desteği anahtarlarını ve değerlerini Go sabitlerine dönüştürür.
- **İç İçe Anahtarlar için Düz Sabitler:** İç içe JSON yapılarını işler, alt çizgi ile ayrılmış adlarla düz sabitler oluşturur.
- **Özelleştirilebilir Çıktı:** Çıktı dosyası adını ve paket adını belirlemenizi sağlar.
- **Dizin Oluşturma:** Çıktı dizini mevcut değilse otomatik olarak oluşturur.

## Neden `musale` Kullanılmalı?

### **1. Dil Desteği Yönetimini Basitleştirir**

Dil Desteği anahtarları genellikle iç içe geçmiş ve hiyerarşiktir, bu da onları manuel olarak yönetmeyi zorlaştırır. musale`, bu iç içe geçmiş yapıları Go kodunuzda kullanımı kolay bir dizi sabit halinde düzleştirir. Bu, Dil Desteği anahtarlarınızın tutarlı ve kolay erişilebilir olmasını sağlar.

### **2. Geliştirici Hatasını Azaltır**

Dil Desteği sabitlerinin oluşturulmasını otomatikleştirerek, `musale` insan hatası riskini azaltır. Manuel anahtar yönetimi tutarsızlıklara ve hatalara yol açabilir. `musale` ile, anahtar oluşturmak için güvenilir ve tekrarlanabilir bir süreç elde edersiniz.

### **3. Kod Okunabilirliğini Geliştirir**

Dil Desteği anahtarları için sabitlerin kullanılması kodun okunabilirliğini ve sürdürülebilirliğini artırır. Kodunuz boyunca ham dizeler kullanmak yerine, amaçlarını açıkça belirten sabitlere başvurabilirsiniz.

## `musale` Nasıl Kullanılır

### **Kurulum**

musale`yi kullanmaya başlamak için aşağıdaki komutu çalıştırın:

```sh
   go install github.com/codermuss/musale@latest
```
### **Anahtarları içeren Go dosyasını oluşturun**

Çıktıyı almak için temel komut aşağıdaki gibidir:
   ```sh
   musale --json=<input-json-file> --output=<output-go-file>
   ```

**Argümanlar**
    
    •	--json ya da -j: Yerelleştirme Anahtarlarını içeren dosyanın yolu (varsayılan: en.json).
	•	--output or -o: Anahtarları içeren Go dosyasının yolu (varsayılan: localizations.g.go).
	•	--package or -p: (Opsiyonel) Üretilen Go dosyası için paket adı.

### **Örnek JSON Dosyası**

> **_NOT:_** Blog'un devamında olan `LocalizationManager` yaklaşımı kullanılacaksa argümanlı yerelleştirmeler için .arg kullanılmalıdır ve 0 dan başlamalıdır (örnek: {{.arg0}}, {{.arg01}}..... {{.argN}}). Bu şablondaki argümanları `LocalizationManager`anlamlandırabilir ve rahatça argümanlı olarak yerelleştirmenizi sağlar. 

```json
{
  "Menu": {
    "File": {
      "Open": "Open File",
      "Close": "Close File"
    },
    "Profile": {
      "Hello": "Hello {{.arg0}}"
    }
  }
}
```
### **Çalıştırılan Script**
```sh
   musale --json=en.json --output=localizations.go --package=localizationkeys
```
### **Üretilen Go Dosyası**
```go
package localizationkeys

// DO NOT EDIT: This file is automatically generated by the musale CLI tool.

const (
	Menu_File_Open  = "Menu.File.Open"
	Menu_File_Close = "Menu.File.Close"
	Menu_Edit_Undo  = "Menu.Edit.Undo"
    Profile_Hello  = "Profile.Hello"
)
```


# Go Uygulamalarında Dil Desteğini Yönetme: `LocalizationManager` Kullanım Kılavuzu

Dil desteği, birden fazla dili desteklemesi gereken uygulamalar için çok önemlidir. Go'da dil desteğini verimli bir şekilde yönetmek, çeviri mantığını merkezileştirmeyi ve uygulamanızın her yerinde erişilebilir olmasını sağlamayı içerir. Şimdi, bir `LocalizationManager` sınıfı kullanarak dil desteğini yönetmek için kurguladığım yaklaşımı keşfedeceğiz ve bunu uygulamanıza küresel olarak entegre etmek için çeşitli yöntemler kullanacağız.

## `LocalizationManager` ile tanışın :)

LocalizationManager`, bir Go uygulamasında çevirilerin yüklenmesi ve getirilmesi için tasarlanmıştır. Yerelleştirilmiş dizelere erişmek ve dil dosyalarını yönetmek için temiz bir arayüz sağlar. İşte temel özelliklerine hızlı bir genel bakış:

- **Çeviri Yükleme**: Farklı diller için çeviri dosyalarını yükler.
- **Çevirileri Getirme**: Parametrelendirilmiş içerik desteği ile yerelleştirilmiş dizeleri alır.
- **Birden Fazla Dili Yönetme**: Birden fazla dili verimli bir şekilde yönetir ve ihtiyaç duyulduğunda çevirilerin kullanılabilir olmasını sağlar.

## `LocalizationManager`ın Uygulanması

### `LocalizationManager` Struct'ını tanımlayın

İşte `LocalizationManager`ın temel bir uygulaması:

```go
package localization

import (
	"encoding/json"
	"fmt"
	"log"
	"sync"

	"github.com/mustafayilmazdev/musarchive/util"
	"github.com/nicksnyder/go-i18n/v2/i18n"
	"golang.org/x/text/language"
)

var (
	instance *LocalizationManager
	once     sync.Once
)

// GetInstance returns the global instance of LocalizationManager.
func Instance() *LocalizationManager {
	return instance
}

func InitLocalization(defaultLang string) {
	once.Do(func() {
		instance = newLocalizationManager(defaultLang)
	})
}

// LocalizationManager handles loading and fetching translations.
type LocalizationManager struct {
	bundle      *i18n.Bundle
	localizers  map[string]*i18n.Localizer
	loadedLangs map[string]bool
	mu          sync.RWMutex
}

// NewLocalizationManager creates a new LocalizationManager.
func newLocalizationManager(defaultLang string) *LocalizationManager {
	bundle := i18n.NewBundle(language.English)
	bundle.RegisterUnmarshalFunc("json", json.Unmarshal)

	manager := &LocalizationManager{
		bundle:      bundle,
		localizers:  make(map[string]*i18n.Localizer),
		loadedLangs: make(map[string]bool),
	}

	// Load default language files
	if err := manager.LoadLanguage(defaultLang); err != nil {
		log.Fatalf("Failed to load default language files: %v", err)
	}

	return manager
}

// LoadLanguage loads translation files for a specific language.
func (lm *LocalizationManager) LoadLanguage(lang string) error {
	lm.mu.Lock()
	defer lm.mu.Unlock()

	if lm.loadedLangs[lang] {
		return nil
	}

	if err := lm.loadLanguageFiles(lang); err != nil {
		return err
	}

	lm.localizers[lang] = i18n.NewLocalizer(lm.bundle, lang)
	lm.loadedLangs[lang] = true
	return nil
}

// loadLanguageFiles loads translation files for a specific language.
func (lm *LocalizationManager) loadLanguageFiles(lang string) error {
	_, err := lm.bundle.LoadMessageFile(fmt.Sprintf("%s%s%s", util.LocalizationPath, lang, util.LocalizationType))
	return err
}

// Translate fetches a localized string for a given language, message ID, and positional parameters.
func (lm *LocalizationManager) Translate(lang, messageID string, args ...interface{}) string {
	lm.mu.RLock()
	localizer, exists := lm.localizers[lang]
	lm.mu.RUnlock()

	// Load language if not already loaded
	if !exists {
		if err := lm.LoadLanguage(lang); err != nil {
			return fmt.Sprintf("[Failed to load language %s: %s]", lang, err)
		}
		lm.mu.RLock()
		localizer = lm.localizers[lang]
		lm.mu.RUnlock()
	}

	// Prepare parameter map
	params := make(map[string]interface{})
	for i, arg := range args {
		params[fmt.Sprintf("arg%d", i)] = arg
	}

	message, err := localizer.Localize(&i18n.LocalizeConfig{
		MessageID:    messageID,
		TemplateData: params,
	})
	if err != nil {
		return fmt.Sprintf("[Error localizing message: %s]", err)
	}
	return message
}

```

## `LocalizationManager` ve `musale` kullanarak çeviri yapılması
```go
package main

import (
    "fmt"
    "log"
    "locales/localization" 
)

func main() {
    // Initialize the LocalizationManager
    localization.InitLocalization(util.DefaultLocale)

    // Use generated keys for translation
    fmt.Println(localization.Instance().Translate(util.DefaultLocale, localization.Menu_File_Open))
    fmt.Println(localization.Instance().Translate(util.DefaultLocale, localization.Menu_File_Close))
    fmt.Println(localization.Instance().Translate(util.DefaultLocale, localization.Menu_Edit_Undo))

    // Use params for arguments
    fmt.Println(localization.Instance().Translate(util.DefaultLocale, localization.Profile_Hello, "John Doe"))
}
```

Bugünlük bu kadardı. Umarım faydalı bir yaklaşım olmuştur.
Özel uygulamanıza veya ihtiyaçlarınıza göre bu yaklaşımı düzenlemekten veya genişletmekten çekinmeyin!